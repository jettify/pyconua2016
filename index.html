<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>PyConUA 2016</title>

		<meta name="description" content="Building Apps With Asyncio">
		<meta name="author" content="Nikolay Novik">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css" id="theme">
		<link rel="stylesheet" href="css/my.css">

		<!-- Code syntax highlighting -->
        <link class="codestyle" rel="stylesheet" href="css/tomorrow.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
<!-- ####################################################################  -->
               <section id="intro" class="aboutme">
                    <img src='images/ava5.png' style="background:none; border:none; box-shadow:none;">
                    <h1></h1>
                    <h1></h1>

					<h3>Building Apps With Asyncio</h3>
					<p> Nikolay Novik</p>
						<small> <a href="http://github.com/jettify">http://github.com/jettify</a></small>
					</p>
					<p>PyConUA 2016</p>
			   </section>
<!-- ####################################################################  -->
				<section id="aobut_me">
                    <h3>I am ...</h3>
                    <ul>
                        <li><b>Software Engineer</b>: at DataRobot Ukraine</li>
                        <li><b>Github</b>: <a href="http://github.com/jettify">https://github.com/jettify</a></li>
                        <li><b>Twitter</b>: <a href="https://twitter.com/isinf">https://twitter.com/isinf</a></li>
                        <li><b>My Projects</b>:
                            <ul>
                                <!-- TODO: add link to each project -->
                                <li><i>database clients</i>: <code>aiomysql, aioobc, aiogibson</code></li>
                                <li><i>web and etc</i>: <code>aiohttp_debugtoolbar, aiobotocore,
                                    aiohttp_mako, aiohttp_admin</code></li>
                            </ul>
                        </li>
                    </ul>
				</section>
<!-- ####################################################################  -->
				<section id="poll"> <h5> Poll: you and asyncio</h5>
                    <img src='images/batman.jpg'>
                    <ol>
                        <li>I am using asyncio/aiohttp extensively</li>
                        <li>I am using Twisted, Tornado, gevent etc. extensively</li>
                        <li>I think async programming is kinda cool</li>
                    </ol>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Agenda</h6>
                    <ol>
                        <li>Motivation, why asyncio and asynchronous programming</li>
                        <li>Asyncio application design choices</li>
                        <li>Tips and tricks and things to consider in your app</li>
                        <li>Asyncio pitfalls</li>
                    </ol>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Motivation. Why you might want to write asynchronous code?</h6>
                    <ul>
                        <li>Bunch of shiny new frameworks</li>
                        <li>Idle protocols (websockets) work out of box</li>
                        <li>One can do useful work instead of blocking</li>
                        <li>Encourage good development practices</li>
                    </ul>
				</section>
<!-- ####################################################################  -->
				<section>
                    <h6>Also we do SOA (<strike>microservices</strike>) this days...</h6>

                    <p><img src="images/microservices.png" height=450px></p>
                    <p>SOA implies a lot of network communications.</p>
                    <!-- <a href="https://www.tigerteam.dk/2014/microservices-its-not-only-the-size-that-matters-its-also-how-you-use-them-part-4/">image source</a> -->
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Sync does not scale (TM)</h6>
                    <pre><code class="hljs python" data-trim>
from django.http import HttpResponse
def my_view(request):
    # blocks thread
    r = requests.get('http://graph.facebook.com/v2.5/{uid}')
    data = r.json()
    # ...
    return HttpResponse(status=200)

# --------------------------------------

from aiohttp import web
async def my_view(request):
    session = request.app['session']
    # context switch here
    r = await session.get('http://graph.facebook.com/v2.5/{uid}')
    data = await r.json()
    return web.Response(status=200)
                    </code></pre>
                    Amazon S3 API could return response in over 9000s!
				</section>
<!-- ####################################################################  -->
				<section>
                    <h6>Asyncio application design choices</h6>
                    <ul>
                        <li>Event loop are spins in <b>main</b> thread, it schedules blocking tasks using
                            thread pool.</li>
                        <li>Embedded event loop, <b>main</b> thread gives control to the event loop
                            for finite amount of time, and then executes regular sync code.</li>
                        <li>Sync code executed in <b>main</b> thread, but event loop spinning
                            in separate thread.</li>
                    </ul>
                </section>
<!-- ####################################################################  -->
				<section>
                    <h6>Asyncio is in main thread</h6>
                    <img src="images/asyncio_leader.svg" height="500px">
                    <p>Most popular and convenient asyncio mode in the wild.</p>
                </section>
<!-- ####################################################################  -->
				<section>
                    <h6>Asyncio is in main thread. Blocking calls are in ThreadPool</h6>
					<pre><code class="hljs python" data-trim>
import asyncio
from pyodbc import connect

loop = asyncio.get_event_loop()
executor = ThreadPoolExecutor(max_workers=4)
async def test_example():
    dsn = 'Driver=SQLite;Database=sqlite.db'
    conn = await loop.run_in_executor(executor, connect, dsn)
    cursor = await loop.run_in_executor(executor, conn.cursor)
    conn = await loop.run_in_executor(executor, cursor.execute,
                                      'SELECT 42;')

loop.run_until_complete(test_example())
					</code></pre>
                    Easy to use but a bit strange interface,
                    default executor has 4 worker threads.

                </section>
<!-- ####################################################################  -->
				<section>
                    <h6>ThreadPool Notes</h6>
                    <ul>
                        <li>No way to kill thread if task stuck inside</li>
                        <li>C extensions could consumer alot of virtual memory due to
                        thread arena</li>
                        <li>Convenient workaround for blocking calls</li>
                    </ul>

                </section>
<!-- ####################################################################  -->
				<section>
                    <h6>Asyncio is in main thread. Blocking code in ProcessPool</h6>
					<pre><code class="hljs python" data-trim>

loop = asyncio.get_event_loop()
executor = ProcessPoolExecutor(max_workers=3)

def is_prime(n):
    if n % 2 == 0: return False
    sqrt_n = int(math.floor(math.sqrt(n)))
    for i in range(3, sqrt_n + 1, 2): if n % i == 0: return False
    return True

async def go():
    result = await loop.run_in_executor(
        executor, is_prime, 112272535095293)
loop.run_until_complete(go(loop, executor))

					</code></pre>
                    <code>ProcessPoolExecutor</code> has same interface as
                    <code>ThreadPoolExecutor</code>
                </section>
<!-- ####################################################################  -->
				<section>
                    <h6>ProcessPool Notes</h6>
                    <ul>
                        <li>Easy to terminate</li>
                        <li>Consumes a lot of memory</li>
                        <li>Process should be created and warmed as soon as
                            possible in order not to copy memory due to
                            <code>fork()</code></li>
                    </ul>

                </section>
<!-- ####################################################################  -->
				<section>
                    <h6>Embedded Asyncio loop</h6>
                    <img src="images/loop_inside.svg" height="500px">
                    <p>Application may spin event loop on will to perform
                    IO heavy computations.</p>
                </section>
<!-- ####################################################################  -->
				<section>
                    <h6>Embedded Asyncio loop. Example</h6>
					<pre><code class="hljs python" data-trim>
import asyncio, aiohttp

async def fetch(session, url, loop):
    async with session.get(url) as resp:
        data = await resp.text()

def collect_data(url_list):
    loop = asyncio.get_event_loop()

    session = aiohttp.ClientSession(loop=loop)
    coros = [fetch(sessiong, u, loop) for u in url_list]

    data = loop.run_until_complete(asyncio.gather(*coros, loop=loop))
    loop.run_until_complete(session.close())
    loop.close()
    return data

def main():
    url_list = db.fetch_urls()
    data = collect_data(url_list)
    process(data)
					</code></pre>
                    Scraping  or concurrent upload to external server are most
                    popular use cases.
                </section>
<!-- ####################################################################  -->
				<section>
                    <h6>Do not try this at home!</h6>
					<pre><code class="hljs python" data-trim>
from flask import Flask
app = Flask(__name__)

loop = asyncio.get_event_loop()
redis = loop.run_until_complete(aioredis.create_redis(
    ('localhost', 6379), loop=loop))

@app.route("/")
def hello():
    value = loop.run_until_complete(redis.get('my-key'))
    return "Hello {}!".format(value)

if __name__ == "__main__":
    app.run()
					</code></pre>
                    Using coroutines inside sync code is not always good idea.
                    In this particular case it slows down database access.
                </section>
<!-- ####################################################################  -->
				<section>
                    <h6>Asyncio loop has own separate thread</h6>
                    <img src="images/sync_leader.svg" height="500px">
                    <p>Application may delegate IO heavy tasks for dedicated
                    loop in separate thread.</p>
                </section>
<!-- ####################################################################  -->
				<section>
                    <h6>Asyncio loop has own separate thread. Example</h6>
					<pre><code class="hljs python" data-trim>
import asyncio, functools
from threading import Thread, Event

class AioThread(Thread):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.loop = None
        self.event = Event()

    def run(self):
        self._loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self._loop)
        self._loop.call_soon(self.event.set)
        self._loop.run_forever()

    def add_task(self, coro):
        fut = asyncio.call_soon_threadsafe(coro, loop=self._loop)
        return fut

    def finalize(self, timeout=None):
        self._loop.call_soon_threadsafe(self._loop.stop)
        self.join(timeout=timeout)
					</code></pre>
                    Simple way to spin event loop in separate thread.

                </section>
<!-- ####################################################################  -->
				<section>
                    <h6>Fetch results from event loop</h6>
					<pre><code class="hljs python" data-trim>
def main()
    aiothread = AioThread()
    aiothread.start()
    aiothread.event.wait()

    loop = aiothread.loop
    coro = asyncio.sleep(1, loop=loop)
    future = aiothread.add_task(coro)
    try:
        result = future.result(timeout)
    except asyncio.TimeoutError:
        print('The coroutine took too long, cancelling the task...')
        future.cancel()
    except Exception as exc:
        print('The coroutine raised an exception: {!r}'.format(exc))
    else:
        print('The coroutine returned: {!r}'.format(result))
					</code></pre>
                </section>
<!-- ####################################################################  -->
				<section>
                    <h6>Real world example: Cassandra python driver</h6>
					<pre><code class="hljs python" data-trim>
class TwistedConnection(Connection):

    @classmethod
    def initialize_reactor(cls):
        cls._loop = TwistedLoop()

    def add_connection(self):
        # ...
    def client_connection_made(self):
        # ...

    def handle_read(self):
        self.process_io_buffer()

    def push(self, data):
        reactor.callFromThread(self.connector.transport.write, data)
					</code></pre>
                    Cassandra's <a href="https://github.com/datastax/python-driver/blob/master/cassandra/io/twistedreactor.py">python driver</a>
                    is sync but connection objects spin event loop, in this case twisted's reactor
                </section>
<!-- ####################################################################  -->
				<section>
                    <h6>Advanced sync/async communication. Janus queue</h6>
                    <p><img src="images/janus.jpg" height=400px></p>
					<pre><code class="hljs python" data-trim>
queue = janus.Queue(loop=loop)
await queue.async_q.get()
queue.sync_q.put(i)
					</code></pre>
				</section>
<!-- ####################################################################  -->
				<section>
                    <h6>Janus queue example</h6>
					<pre><code class="hljs python" data-trim>
import asyncio, janus

loop = asyncio.get_event_loop()
queue = janus.Queue(loop=loop)

def threaded(sync_q):
    for i in range(100):
        sync_q.put(i)
    sync_q.join()

async def async_coro(async_q):
    for i in range(100):
        val = await async_q.get()
        async_q.task_done()

fut = loop.run_in_executor(None, threaded, queue.sync_q)
loop.run_until_complete(async_coro(queue.async_q))
loop.run_until_complete(fut)
					</code></pre>
                    <code>janus</code> has two APIs for same queue: sync like
                    <code>queue.Queue</code> and async like <code>asyncio.Queue</code>
                </section>
<!-- ####################################################################  -->
				<section>
                    <h6>Asyncio tips and tricks</h6>
                    <img src="images/funny.jpg" height="600px">
				</section>
<!-- ####################################################################  -->
				<section>
                    <h6>TIP: Use Explicit Event Loop</h6>
					<pre><code class="hljs python" data-trim>
import asyncio

async def go(loop):
    future = asyncio.Future(loop=loop)
    future.set_result(None)

    await asyncio.sleep(3.0, loop=loop)
    await future
    print("foo")

loop = asyncio.get_event_loop()
loop.run_until_complete(go(loop))
loop.close()
					</code></pre>
                    <code>loop</code> argument is required for most asyncio APIs.
				</section>
<!-- ####################################################################  -->
				<section>
                    <h6>Glyph on global event loop</h6>
                    <blockquote>
                        <p>It would really be a pity if Tulip repeated our billion-dollar mistake [global reactor] ;-)</p>
                        <footer>--Glyph Lefkowitz / author of Twisted</footer>
                    </blockquote>
                    <a href="https://groups.google.com/forum/#!msg/python-tulip/hr1kPZfMX8U/9uqdlbRuRsoJ">https://groups.google.com/forum/#!msg/python-tulip/hr1kPZfMX8U/9uqdlbRuRsoJ</a>
				</section>
<!-- ####################################################################  -->
				<section>
                    <h6>Convenience of explicit loop</h6>
                    <ul>
                        <li>Increase of testability (Hello Twisted!)</li>
                        <li>Fast access to bunch of useful methods: <code>run_in_executor,
                                create_subprocess_exec, create_task </code></li>
                        <li>Easier to reason about code when you have nonstandard case like: two
                            threads two event loops, or main thread is sync second is async</li>
                    </ul>
				</section>
<!-- ####################################################################  -->
				<section>
                    <h6>TIP: Think about graceful shutdown early</h6>
                    <p><img src="images/kill-9-1.jpg"></p>
				</section>
<!-- ####################################################################  -->
				<section>
                    <h6>Asyncio graceful shutdown</h6>
					<pre><code class="hljs python" data-trim>
import asyncio, signal

is_working = True
async def do_work(loop):
    while is_working:
        await asyncio.sleep(1, loop=loop)

def signal_handler(loop):
    loop.remove_signal_handler(signal.SIGTERM)
    is_working = False

loop = asyncio.get_event_loop()
loop.add_signal_handler(signal.SIGTERM, signal_handler, loop)
loop.run_until_complete(do_work(loop))
					</code></pre>
                    <code>asyncio</code> will warn you with bunch of tracebacks
                    if you do not do proper shutdown.
				</section>
<!-- ####################################################################  -->
				<section>
                    <h6>Graceful shutdown aiohttp edition </h6>
                    <pre><code class="hljs python" data-trim>

loop = asyncio.get_event_loop()
handler = app.make_handler()
f = loop.create_server(handler, '0.0.0.0', 8080)
srv = loop.run_until_complete(f)

def shutdown(loop)
    loop.remove_signal_handler(signal.SIGTERM)
    loop.stop()

loop.add_signal_handler(signal.SIGTERM, shutdown, loop)

loop.run_forever()

srv.close()  # finish socket listening
loop.run_until_complete(srv.wait_closed())

loop.run_until_complete(app.shutdown())  # close websockets
loop.run_until_complete(handler.finish_connections(60.0))
loop.run_until_complete(app.cleanup())  # doc registered cleanups
loop.close()
                    </code></pre>
                    Now you can be sure that all requests are safe and served
                    and new requests is not accepted

				</section>
<!-- ####################################################################  -->
				<section>
                    <h6>TIP: Think About Resource Lifetime to Avoid Resource
                        (Socketes) Leak</h6>
                    <p><img src="images/sockets.jpg" height="400px"></p>
                    Good candidates for extra care:
                    <ul>
                        <li>Any rest calls to external services</li>
                        <li>Any reconnection logic</li>
                    </ul>

				</section>
<!-- ####################################################################  -->
				<section>
                    <h6>Make sure all responses has been released</h6>
                    <code>aiohttp.ClientSession</code> is your friend
					<pre><code class="hljs python" data-trim>
import asyncio
import aiohttp


async def go(loop):
    session = aiohttp.ClientSession(loop=loop)
    async with session.get('http://ua.pycon.org') as resp:
        data = await resp.text()
        print(data)
    session.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(go(loop))
					</code></pre>
                Connection pooling helps to save on expensive connection
                creation.
				</section>
<!-- ####################################################################  -->
				<section>
                    <h6>Be a good citizen! Shutdown db connection pools
                        in your aiohttp app</h6>
					<pre><code class="hljs python" data-trim>
async def init(loop):
    # setup application and extensions
    app = web.Application(loop=loop)

    # create connection to the database
    pg = await init_postgres(conf['postgres'], loop)

    async def close_pg(app):
        pg.close()
        await pg.wait_closed()

    app.on_cleanup.append(close_pg)
    # ...
					</code></pre>
                    <code>aiohttp</code> has handy signal <b>on_cleanup</b> for
                    database connections, as well as <b>on_shutdown</b> for
                    websockets
				</section>

<!-- ####################################################################  -->
				<section>
                    <h6>Explicitly finalize background tasks</h6>
					<pre><code class="hljs python" data-trim>
class Foo:

    def __init__(self):
        self._task = asyncio.create_task(self._do_task(),
        loop=self._loop)

    async def _do_task():
        await self.set('foo', 'bar')
        await self.set('baz', 'zap')

    async def _stop_do_task(self):
        await self._task
					</code></pre>
                    May be very tricky! Same approach as thread finalization
                    should be employed or <code>task.cancel()</code></section>
<!-- ####################################################################  -->
				<section>
					<h6>Asyncio Pitsfalls</h6>
                    <p><img src="images/train_fall.jpg" height=650px></p>
				</section>

<!-- ####################################################################  -->
				<section>
					<h6>Keep an eye on StopIteration in python 3.4</h6>
					<pre><code class="hljs python" data-trim>
@asyncio.coroutine
def coro():
    raise StopIteration('batman')

@asyncio.coroutine
def coro2():
    i = iter(range(2))
    next(i)
    next(i)
    next(i)  # raise StopIteration
    return 'finish'

@asyncio.coroutine
def go():
    data = yield from coro()  # batman
    data = yield from coro2() # None
					</code></pre>
                    Fixed in python 3.5
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Missed coroutine decorators in python 3.4</h3>
					<pre><code class="hljs python" data-trim>
@asyncio.coroutine
def foo(loop):
    yield from asyncio.sleep(1, loop=loop)

def bar(loop):
    yield from asyncio.sleep(1, loop=loop)

loop.run_until_complete(foo(loop))
loop.run_until_complete(bar(loop))

					</code></pre>
                    Fixed in python 3.5 with await syntax
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Think 7 times before using task.cancel()</h6>
					<pre><code class="hljs python" data-trim>
async def foo(loop):
    await update1()
    await update2()

task = loop.ensure_future(foo(loop))
task.cancel()
					</code></pre>
                    Fixed in python 3.5 with await syntax
				</section>

<!-- ####################################################################  -->
				<section style="text-align: left;" data-background="images/dr2.png" data-state="img-right">
					<h1>THE END</h1>
					<p>
						<a href="http://jettify.github.io/pyconua2016"> http://jettify.github.io/pyconua2016</a> <br>
                    </p>
				</section>
<!-- ####################################################################  -->

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
